{"version":3,"file":null,"sources":["../src/util.js","../src/hotline.js","../src/renderer.js","../src/plugin.js","../src/leaflet.hotline.js"],"sourcesContent":["import L from 'leaflet';\n\n\nfunction clipSegment(a, b, bounds, useLastCode, round) {\n\tvar codeA = useLastCode ? this._lastCode : L.LineUtil._getBitCode(a, bounds),\n\tcodeB = L.LineUtil._getBitCode(b, bounds),\n\tcodeOut, p, newCode;\n\n\t// save 2nd code to avoid calculating it on the next segment\n\tthis._lastCode = codeB;\n\n\twhile (true) {\n\t\t// if a,b is inside the clip window (trivial accept)\n\t\tif (!(codeA | codeB)) {\n\t\t\treturn [a, b];\n\t\t// if a,b is outside the clip window (trivial reject)\n\t\t} else if (codeA & codeB) {\n\t\t\treturn false;\n\t\t// other cases\n\t\t} else {\n\t\t\tcodeOut = codeA || codeB;\n\t\t\tp = L.LineUtil._getEdgeIntersection(a, b, codeOut, bounds, round);\n\t\t\tnewCode = L.LineUtil._getBitCode(p, bounds);\n\n\t\t\tif (codeOut === codeA) {\n\t\t\t\tp.z = a.z;\n\t\t\t\ta = p;\n\t\t\t\tcodeA = newCode;\n\t\t\t} else {\n\t\t\t\tp.z = b.z;\n\t\t\t\tb = p;\n\t\t\t\tcodeB = newCode;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nexport default {\n\tclipSegment: clipSegment\n};\n","/**\n * Core renderer.\n * @constructor\n * @param {HTMLElement | string} canvas - &lt;canvas> element or its id\n * to initialize the instance on.\n */\nexport var Hotline = function (canvas) {\n\tif (!(this instanceof Hotline)) { return new Hotline(canvas); }\n\n\tvar defaultPalette = {\n\t\t0.0: 'green',\n\t\t0.5: 'yellow',\n\t\t1.0: 'red'\n\t};\n\n\tthis._canvas = canvas =\n\t\ttypeof canvas === 'string' ? document.getElementById(canvas) : canvas;\n\n\tthis._ctx = canvas.getContext('2d');\n\tthis._width = canvas.width;\n\tthis._height = canvas.height;\n\n\tthis._weight = 5;\n\tthis._outlineWidth = 1;\n\tthis._outlineColor = 'black';\n\n\tthis._min = 0;\n\tthis._max = 1;\n\n\tthis._data = [];\n\n\tthis.palette(defaultPalette);\n};\n\nHotline.prototype = {\n\t/**\n\t * Sets the width of the canvas. Used when clearing the canvas.\n\t * @param {number} width - Width of the canvas.\n\t */\n\twidth: function (width) {\n\t\tthis._width = width;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Sets the height of the canvas. Used when clearing the canvas.\n\t * @param {number} height - Height of the canvas.\n\t */\n\theight: function (height) {\n\t\tthis._height = height;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Sets the weight of the path.\n\t * @param {number} weight - Weight of the path in px.\n\t */\n\tweight: function (weight) {\n\t\tthis._weight = weight;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Sets the width of the outline around the path.\n\t * @param {number} outlineWidth - Width of the outline in px.\n\t */\n\toutlineWidth: function (outlineWidth) {\n\t\tthis._outlineWidth = outlineWidth;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Sets the color of the outline around the path.\n\t * @param {string} outlineColor - A CSS color value.\n\t */\n\toutlineColor: function (outlineColor) {\n\t\tthis._outlineColor = outlineColor;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Sets the palette gradient.\n\t * @param {Object.<number, string>} palette  - Gradient definition.\n\t * e.g. { 0.0: 'white', 1.0: 'black' }\n\t */\n\tpalette: function (palette) {\n\t\tvar canvas = document.createElement('canvas'),\n\t\tctx = canvas.getContext('2d'),\n\t\tgradient = ctx.createLinearGradient(0, 0, 0, 256);\n\n\t\tcanvas.width = 1;\n\t\tcanvas.height = 256;\n\n\t\tfor (var i in palette) {\n\t\t\tgradient.addColorStop(i, palette[i]);\n\t\t}\n\n\t\tctx.fillStyle = gradient;\n\t\tctx.fillRect(0, 0, 1, 256);\n\n\t\tthis._palette = ctx.getImageData(0, 0, 1, 256).data;\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Sets the value used at the start of the palette gradient.\n\t * @param {number} min\n\t */\n\tmin: function (min) {\n\t\tthis._min = min;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Sets the value used at the end of the palette gradient.\n\t * @param {number} max\n\t */\n\tmax: function (max) {\n\t\tthis._max = max;\n\t\treturn this;\n\t},\n\n\t/**\n\t * A path to rander as a hotline.\n\t * @typedef Array.<{x:number, y:number, z:number}> Path - Array of x, y and z coordinates.\n\t */\n\n\t/**\n\t * Sets the data that gets drawn on the canvas.\n\t * @param {(Path|Path[])} data - A single path or an array of paths.\n\t */\n\tdata: function (data) {\n\t\tthis._data = data;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Adds a path to the list of paths.\n\t * @param {Path} path\n\t */\n\tadd: function (path) {\n\t\tthis._data.push(path);\n\t\treturn this;\n\t},\n\n\t/**\n\t * Clears the canvas and optionally resets the data.\n\t * @param {boolean} clearData - Also clear the data.\n\t */\n\tclear: function (clearData) {\n\t\tif (clearData) {\n\t\t\tthis._data = [];\n\t\t}\n\t\tthis._ctx.clearRect(0, 0, this._width, this._height);\n\t\treturn this;\n\t},\n\n\t/**\n\t * Draws the currently set paths.\n\t * @param {boolean} clear - Don't draw as a hotline but remove the currently\n\t * set paths without clearing the complete canvas.\n\t */\n\tdraw: function (clear) {\n\t\tvar ctx = this._ctx;\n\n\t\tctx.globalCompositeOperation = clear ? 'destination-out' : 'source-over';\n\t\tctx.lineCap = 'round';\n\n\t\tthis._drawOutline(ctx, clear);\n\n\t\t// No need to draw expensive gradients when clearing\n\t\tif (clear) { return this; }\n\n\t\tthis._drawHotline(ctx);\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Gets the RGB values of a given z value of the current palette.\n\t * @param {number} value - Value to get the color for, should be between min and max.\n\t * @returns {Array.<number>} The RGB values as an array [r, g, b]\n\t */\n\tgetRGBForValue: function (value) {\n\t\tvar valueRelative = Math.min(Math.max((value - this._min) / (this._max - this._min), 0), 0.999);\n\t\tvar paletteIndex = Math.floor(valueRelative * 256) * 4;\n\n\t\treturn [\n\t\t\tthis._palette[paletteIndex],\n\t\t\tthis._palette[paletteIndex + 1],\n\t\t\tthis._palette[paletteIndex + 2]\n\t\t];\n\t},\n\n\t/**\n\t * Draws the outline of the graphs.\n\t * @private\n\t */\n\t_drawOutline: function (ctx, clear) {\n\t\tvar i, j, dataLength, path, lineWidth, pathLength, pointStart, pointEnd;\n\n\t\tif (clear || this._outlineWidth) {\n\t\t\tfor (i = 0, dataLength = this._data.length; i < dataLength; i++) {\n\t\t\t\tpath = this._data[i];\n\t\t\t\tlineWidth = this._weight + 2 * this._outlineWidth;\n\n\t\t\t\t// If clearing a path, do it with its previous line width and a little bit extra\n\t\t\t\tpath._prevWidth = ctx.lineWidth = clear ? (path._prevWidth || lineWidth) + 1 : lineWidth;\n\n\t\t\t\tfor (j = 1, pathLength = path.length; j < pathLength; j++) {\n\t\t\t\t\tpointStart = path[j - 1];\n\t\t\t\t\tpointEnd = path[j];\n\n\t\t\t\t\tctx.strokeStyle = this._outlineColor;\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(pointStart.x, pointStart.y);\n\t\t\t\t\tctx.lineTo(pointEnd.x, pointEnd.y);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Draws the color encoded hotline of the graphs.\n\t * @private\n\t */\n\t_drawHotline: function (ctx) {\n\t\tvar i, j, dataLength, path, pathLength, pointStart, pointEnd,\n\t\tgradient, gradientStartRGB, gradientEndRGB;\n\n\t\tctx.lineWidth = this._weight;\n\n\t\tfor (i = 0, dataLength = this._data.length; i < dataLength; i++) {\n\t\t\tpath = this._data[i];\n\n\t\t\tfor (j = 1, pathLength = path.length; j < pathLength; j++) {\n\t\t\t\tpointStart = path[j - 1];\n\t\t\t\tpointEnd = path[j];\n\n\t\t\t\t// Create a gradient for each segment, pick start end end colors from palette gradient\n\t\t\t\tgradient = ctx.createLinearGradient(pointStart.x, pointStart.y, pointEnd.x, pointEnd.y);\n\t\t\t\tgradientStartRGB = this.getRGBForValue(pointStart.z);\n\t\t\t\tgradientEndRGB = this.getRGBForValue(pointEnd.z);\n\t\t\t\tgradient.addColorStop(0, 'rgb(' + gradientStartRGB.join(',') + ')');\n\t\t\t\tgradient.addColorStop(1, 'rgb(' + gradientEndRGB.join(',') + ')');\n\n\t\t\t\tctx.strokeStyle = gradient;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(pointStart.x, pointStart.y);\n\t\t\t\tctx.lineTo(pointEnd.x, pointEnd.y);\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t}\n\t}\n};\n","import L from 'leaflet';\nimport {Hotline} from './hotline.js';\n\n\nexport var Renderer = L.Canvas.extend({\n\t_initContainer: function () {\n\t\tL.Canvas.prototype._initContainer.call(this);\n\t\tthis._hotline = new Hotline(this._container);\n\t},\n\n\t_update: function () {\n\t\tL.Canvas.prototype._update.call(this);\n\t\tthis._hotline.width(this._container.width);\n\t\tthis._hotline.height(this._container.height);\n\t},\n\n\t_updatePoly: function (layer) {\n\t\tvar parts = layer._parts;\n\n\t\tif (!parts.length) { return; }\n\n\t\tthis._updateOptions(layer);\n\n\t\tthis._hotline\n\t\t\t.data(parts)\n\t\t\t.draw(this._clear);\n\t},\n\n\t_updateOptions: function (layer) {\n\t\tif (layer.options.min !== null) {\n\t\t\tthis._hotline.min(layer.options.min);\n\t\t}\n\t\tif (layer.options.max !== null) {\n\t\t\tthis._hotline.max(layer.options.max);\n\t\t}\n\t\tif (layer.options.weight !== null) {\n\t\t\tthis._hotline.weight(layer.options.weight);\n\t\t}\n\t\tif (layer.options.outlineWidth !== null) {\n\t\t\tthis._hotline.outlineWidth(layer.options.outlineWidth);\n\t\t}\n\t\tif (layer.options.outlineColor !== null) {\n\t\t\tthis._hotline.outlineColor(layer.options.outlineColor);\n\t\t}\n\t\tif (layer.options.palette) {\n\t\t\tthis._hotline.palette(layer.options.palette);\n\t\t}\n\t}\n});\n\nexport var renderer = function (options) {\n\treturn L.Browser.canvas ? new Renderer(options) : null;\n};\n","import L from 'leaflet';\nimport {Renderer, renderer} from './renderer.js';\nimport Util from './util.js';\n\n\nexport var Plugin = L.Polyline.extend({\n\tstatics: {\n\t\tRenderer: Renderer,\n\t\trenderer: renderer\n\t},\n\n\toptions: {\n\t\trenderer: renderer(),\n\t\tmin: 0,\n\t\tmax: 1,\n\t\tpalette: {\n\t\t\t0.0: 'green',\n\t\t\t0.5: 'yellow',\n\t\t\t1.0: 'red'\n\t\t},\n\t\tweight: 5,\n\t\toutlineColor: 'black',\n\t\toutlineWidth: 1\n\t},\n\n\tgetRGBForValue: function (value) {\n\t\treturn this._renderer._hotline.getRGBForValue(value);\n\t},\n\n\t/**\n\t * Just like the Leaflet version, but with support for a z coordinate.\n\t */\n\t_projectLatlngs: function (latlngs, result, projectedBounds) {\n\t\tvar flat = latlngs[0] instanceof L.LatLng,\n\t\tlen = latlngs.length,\n\t\ti, ring;\n\n\t\tif (flat) {\n\t\t\tring = [];\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n\t\t\t\t// Add the altitude of the latLng as the z coordinate to the point\n\t\t\t\tring[i].z = latlngs[i].alt;\n\t\t\t\tprojectedBounds.extend(ring[i]);\n\t\t\t}\n\t\t\tresult.push(ring);\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tthis._projectLatlngs(latlngs[i], result, projectedBounds);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Just like the Leaflet version, but uses `Util.clipSegment()`.\n\t */\n\t_clipPoints: function () {\n\t\tif (this.options.noClip) {\n\t\t\tthis._parts = this._rings;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._parts = [];\n\n\t\tvar parts = this._parts,\n\t\tbounds = this._renderer._bounds,\n\t\ti, j, k, len, len2, segment, points;\n\n\t\tfor (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n\t\t\tpoints = this._rings[i];\n\n\t\t\tfor (j = 0, len2 = points.length; j < len2 - 1; j++) {\n\t\t\t\tsegment = Util.clipSegment(points[j], points[j + 1], bounds, j, true);\n\n\t\t\t\tif (!segment) { continue; }\n\n\t\t\t\tparts[k] = parts[k] || [];\n\t\t\t\tparts[k].push(segment[0]);\n\n\t\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\n\t\t\t\tif ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {\n\t\t\t\t\tparts[k].push(segment[1]);\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_clickTolerance: function () {\n\t\treturn this.options.weight / 2 + this.options.outlineWidth + (L.Browser.touch ? 10 : 0);\n\t}\n});\n\nexport var plugin = function (latlngs, options) {\n\treturn new Plugin(latlngs, options);\n};\n\n","/*\n (c) 2015, iosphere GmbH\n Leaflet.hotline, a Leaflet plugin for drawing gradients along polylines.\n https://github.com/iosphere/Leaflet.hotline/\n*/\n\nimport L from 'leaflet';\nimport {Plugin, plugin} from './plugin.js';\n\nexport {L};\n\nL.Hotline = Plugin;\n\nL.hotline = plugin;\n\n"],"names":["clipSegment","a","b","bounds","useLastCode","round","codeOut","p","newCode","codeA","this","_lastCode","L","LineUtil","_getBitCode","codeB","_getEdgeIntersection","z","Hotline","canvas","defaultPalette","0","0.5","1","_canvas","document","getElementById","_ctx","getContext","_width","width","_height","height","_weight","_outlineWidth","_outlineColor","_min","_max","_data","palette","prototype","weight","outlineWidth","outlineColor","createElement","ctx","gradient","createLinearGradient","i","addColorStop","fillStyle","fillRect","_palette","getImageData","data","min","max","add","path","push","clear","clearData","clearRect","draw","globalCompositeOperation","lineCap","_drawOutline","_drawHotline","getRGBForValue","value","valueRelative","Math","paletteIndex","floor","j","dataLength","lineWidth","pathLength","pointStart","pointEnd","length","_prevWidth","strokeStyle","beginPath","moveTo","x","y","lineTo","stroke","gradientStartRGB","gradientEndRGB","join","Renderer","Canvas","extend","_initContainer","call","_hotline","_container","_update","_updatePoly","layer","parts","_parts","_updateOptions","_clear","options","renderer","Browser","Plugin","Polyline","statics","_renderer","_projectLatlngs","latlngs","result","projectedBounds","ring","flat","LatLng","len","_map","latLngToLayerPoint","alt","_clipPoints","noClip","_rings","k","len2","segment","points","_bounds","Util","_clickTolerance","touch","plugin","hotline"],"mappings":"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"}